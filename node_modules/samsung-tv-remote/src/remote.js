"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SamsungTvRemote = void 0;
const fs_1 = require("fs");
const child_process_1 = require("child_process");
const os_1 = require("os");
const path_1 = require("path");
const wake_on_lan_1 = require("wake_on_lan");
const ws_1 = __importDefault(require("ws"));
const logger_1 = require("./logger");
class SamsungTvRemote {
    constructor(options) {
        var _a, _b, _c, _d;
        this.logger = new logger_1.SamsungTvLogger();
        if (!options.ip) {
            throw new Error('[SamsungTvRemote]: TV IP address is required');
        }
        // Initialize
        this.options = {
            name: (_a = options.name) !== null && _a !== void 0 ? _a : 'SamsungTvRemote',
            ip: options.ip,
            mac: (_b = options.mac) !== null && _b !== void 0 ? _b : '00:00:00:00:00:00',
            port: (_c = options.port) !== null && _c !== void 0 ? _c : 8002,
            timeout: (_d = options.timeout) !== null && _d !== void 0 ? _d : 1000,
            debug: (options.debug !== undefined) ? options.debug : false
        };
        this.logger.enabled(this.options.debug);
        this.logger.log('Options:', this.options);
        // Retrieve app token (if previously registered)
        const apps = this.getRegisteredApps();
        if (Object.prototype.hasOwnProperty.call(apps, this.options.name)) {
            this.token = apps[this.options.name];
            this.logger.log('Token found:', this.token);
        }
        else {
            this.logger.warn('No token found:', 'app is not registered yet and will need to be authorized on TV');
        }
        // Initialize web socket url
        this.refreshWebSocketURL();
    }
    // --- PUBLIC API(s) ---
    /**
     * Send a key to the TV.
     *
     * @async
     * @param {keyof typeof Keys} key The key to be sent
     * @returns {Promise<void>} A void promise
     */
    sendKey(key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (key) {
                const command = JSON.stringify({
                    method: 'ms.remote.control',
                    params: {
                        Cmd: 'Click',
                        DataOfCmd: key,
                        Option: false,
                        TypeOfRemote: 'SendRemoteKey'
                    }
                });
                const ws = yield this.connect().catch(err => this.logger.error(err));
                if (ws) {
                    this.logger.log('Sending key:', key);
                    if (this.options.port === 8001) {
                        setTimeout(() => ws.send(command), 1000);
                    }
                    else {
                        ws.send(command);
                        setTimeout(() => ws.close(), 250);
                    }
                }
            }
        });
    }
    /**
     * Send multiple keys to the TV.
     *
     * @async
     * @param {(keyof typeof Keys)[]} keys An array of keys to be sent
     * @returns {Promise<void>} A void promise
     */
    sendKeys(keys) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const key of keys) {
                yield this.sendKey(key);
            }
        });
    }
    /**
     * Turn the TV on or awaken it from sleep mode (also called WoL - Wake-on-LAN).
     * The mac address option is required in this case.
     *
     * @async
     * @returns {Promise<void>} A void promise
     */
    wakeTV() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                if (!(yield this.isTvAlive())) {
                    this.logger.log('Waking TV...');
                    (0, wake_on_lan_1.wake)(this.options.mac, { num_packets: 30 }, (error) => __awaiter(this, void 0, void 0, function* () {
                        if (error) {
                            this.logger.error(error);
                            return reject(error);
                        }
                        else {
                            // Gives a little time for the TV to start
                            setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                                if (!(yield this.isTvAlive())) {
                                    const msg = 'TV won\'t wake up';
                                    this.logger.error(msg);
                                    return reject(`[SamsungTvRemote]: Error: ${msg}`);
                                }
                                return resolve();
                            }), 5000);
                        }
                    }));
                }
                else {
                    this.logger.log('Waking TV:', 'already up');
                    return resolve();
                }
            }));
        });
    }
    // --- HELPER(s) ---
    getCachePath(name = 'badisi-samsung-tv-remote.json') {
        var _a, _b;
        const homeDir = (0, os_1.homedir)();
        switch (process.platform) {
            case 'darwin': return (0, path_1.join)(homeDir, 'Library', 'Caches', name);
            case 'win32': return (0, path_1.join)((_a = process.env.LOCALAPPDATA) !== null && _a !== void 0 ? _a : (0, path_1.join)(homeDir, 'AppData', 'Local'), name);
            default: return (0, path_1.join)((_b = process.env.XDG_CACHE_HOME) !== null && _b !== void 0 ? _b : (0, path_1.join)(homeDir, '.cache'), name);
        }
    }
    getRegisteredApps() {
        const filePath = this.getCachePath();
        if ((0, fs_1.existsSync)(filePath)) {
            return JSON.parse((0, fs_1.readFileSync)(filePath).toString());
        }
        return {};
    }
    registerApp(appName, appToken) {
        const filePath = this.getCachePath();
        const apps = this.getRegisteredApps();
        apps[appName] = appToken;
        (0, fs_1.writeFileSync)(filePath, JSON.stringify(apps));
    }
    ;
    refreshWebSocketURL() {
        let url = (this.options.port === 8001) ? 'ws' : 'wss';
        url += `://${this.options.ip}:${this.options.port}/api/v2/channels/samsung.remote.control`;
        url += `?name=${Buffer.from(this.options.name).toString('base64')}`;
        if (this.token) {
            url += `&token=${this.token}`;
        }
        this.wsURL = url;
    }
    isTvAlive() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                (0, child_process_1.exec)(`ping -c 1 -W 1 ${this.options.ip}`, (error) => resolve(!!!error));
            });
        });
    }
    connect() {
        return new Promise((resolve, reject) => {
            this.logger.log('Connecting to TV:', this.wsURL);
            const ws = new ws_1.default(this.wsURL, {
                timeout: this.options.timeout,
                rejectUnauthorized: false
            });
            ws.on('error', (error) => {
                ws.close();
                return reject(error.message);
            });
            ws.on('message', (data) => {
                const msg = JSON.parse(data.toString());
                if (msg.event === 'ms.channel.connect') {
                    // Register app for next time
                    if (!this.token) {
                        this.token = msg.data.token;
                        this.refreshWebSocketURL();
                        this.registerApp(this.options.name, msg.data.token);
                    }
                    return resolve(ws);
                }
                else {
                    ws.close();
                    return reject(msg);
                }
            });
        });
    }
}
exports.SamsungTvRemote = SamsungTvRemote;
;
